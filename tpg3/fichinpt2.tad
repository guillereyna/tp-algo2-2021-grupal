// Fichín:
// Puntero al mapa.
// alguienJugado????
// Puntero a partida (qué onda con null?).
// ranking (dicc-trie).
// Jugador (string).

Representación:
	fichín se representa con estr donde 
		estr es tupla ⟨	mapa: puntero(mapa),
						partida: puntero(partida),
						enCurso: bool,
						ranking: diccTrie⟨jugador, nat⟩,
						jugador: string ⟩
						

Solución Informal:
	- e.arg₀ + 1 debe ser ...
	- si e.arg₁ ...
---
Invariante de Representación:
	Rep:	estr	->	boolean
	(∀e: estr) Rep(e)	≡ true ⇐⇒ (1)∧(2)
		donde: 
		(1)	≡	e.arg₀ > ...
		(2)	≡	(∀n: nat)(e.arg₁ < ...)
---
Función de abstracción:
	Abs:	estr	->	fichín	{Rep(e)}
	(∀e: estr) Abs(e) =obs td: fichín | (1)∧(2)
		donde: 
		(1)	≡	mapa(td) = e->mapa
		(2)	≡	partidaActual(td) = e.->partida
		(3) ≡	alguienJugando?(td) = e.enCurso
		(4) ≡	jugadorActual(td) = e.jugador
		(5) ≡	ranking(td) = e.ranking
---
Interfaz:
	Se explica con:	Fichín
	Géneros:		fichín
	
	Operaciones básicas:
		NuevoFichín(in m: mapa) -> res: fichín
		Pre ≡ {true}
		Post ≡ {res =obs nuevoFichín(m)}
		Complejidad: Θ(1)?
		Descripción: Genera un nuevo fichín.
		Aliasing: ?
		---		
		
		NuevaPartida(inout f: fichín, in j: jugador)
		Pre ≡ {f = f₀ ∧ ¬alguienJugando?(f₀)}
		Post ≡ {f =obs nuevaPartida(f₀, j)}
		Complejidad: Θ(c)
		Descripción: ...
		Aliasing: ?
		---
		
		Mover(inout f: fichín, in d: dirección)
		Pre ≡ {f = f₀ ∧ alguienJugando?(f)}
		Post ≡ {f =obs mover(f₀, d)}
		Complejidad: Θ(1) normalmente / Θ(|J|) cuando ganó o perdió
		Descripción: ...
		Aliasing: ?
		---
		
		Mapa(in f: fichín) -> res: mapa
		Pre ≡ {true}
		Post ≡ {res =obs mapa(f)}
		Complejidad: Θ(1)
		Descripción: ...
		Aliasing: Se devuelve una referencia inmutable.
		---
		
		AlguienJugando?(in f: fichín) -> res: bool
		Pre ≡ {true}
		Post ≡ {res =obs alguienJugando?(f)}
		Complejidad: Θ(1)
		Descripción: ...
		---
		
		JugadorActual(in f: fichín) -> res: jugador
		Pre ≡ {alguienJugando?(f)}
		Post ≡ {res =obs jugadorActual(f₀)}
		Complejidad: Θ(1)
		Descripción: ...
		Aliasing: Se devuelve una referencia inmutable.
		---
		
		PartidaActual(in f: fichín) -> res: partida
		Pre ≡ {alguienJugando?(f)}
		Post ≡ {res = obs PartidaActual(f)}
		Complejidad: Θ(1)
		Descripción: ...
		Aliasing: Se devuelve una referencia inmutable.
		---
		
		Ranking(in fichín: f) -> res: ranking
		Pre ≡ {true}
		Post ≡ {res =obs ranking(f)}
		Complejidad: Θ(1)
		Descripción: ...
		Aliasing: Se devuelve una referencia inmutable.
		---
		
		Objetivo(in f: fichín, out t: tupla(jugador, nat)) -> res: bool
		Pre ≡ {alguienJugando?(f)}
		Post ≡ {si res es true, devuelve el objetivo, sino, no importa.
		las condiciones son: está en el ranking y no es el primero.}
		Complejidad:
		Descripción:
		Aliasing:
		---
		
		
	Algoritmos del módulo:
		iNuevoFichín(in m: puntero(mapa)) -> res: estr
			res.mapa <- m
			res.tablero <- inicializarTablero(m)
			res.partida <- null
			res.enCurso <- false
			res.ranking <- Vacío()
			res.jugador <- null
		---
		
		iMover(inout f: estr, in d: dirección)
			Mover(f->partida, d)
			if (Ganó?(f->partida) ∧ (Def?(f.jugador, f.ranking) ∧ CantMov(f->partida) < f.ranking[f.jugador]) ∨ (¬ Def?(f.jugador, f.ranking)) then
					Definir(f.ranking, f.jugador, CantMov(f->partida))
			f.enCurso <- false
		---
		
		iAlguienJugando?(in f: estr) -> res: bool
			res <- f.enCurso
		---
		
		iPartidaActual(in f: estr) -> res: partida
			res <- f->partida
		---
		
		iObjetivo(in f: fichín) -> res: tupla(jugador, nat)
			Busca en el ranking al jugador con el próximo puntaje más alto y devuelve
			en una tupla su nombre y su puntaje.
			Habría que hacer tener otro ranking pero en forma de secuencia para no tener
			que estar recorriendo el trie? Cuánto cuesta recorrerlo??
			En ese caso sería:
			rankingLineal = ConjuntoLineal(itDiccTrie(jugador, nat))
		---
		iInicializarTablero(in m: mapa)
		t = arreglo[largo(m)] de arreglo[alto(m)] de tupla ⟨bool, bool, bool⟩(false)
		for c in chocolates(m) do
			π₂(t[π₀(c)][π₁(c)]) = true
		end for
		for p in paredes(m) do
			π₀(t[π₀(p)][π₁(p)]) = true
		end for
		for f in fantasmas(m) do
			π₁(t[π₀(f)][π₁(f)]) = true
		end for
