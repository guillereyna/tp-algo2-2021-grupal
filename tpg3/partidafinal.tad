Representación:
	tipoDato se representa con estr donde 
		estr es tupla ⟨ mapa: puntero(mapa),
									 tablero: puntero(array(array(tupla(bool, bool, bool))))
									 cantMov: nat,
									 coordenadaActual: coordenada, //tupla⟨nat, nat⟩ 
									 movsInmunes: nat,
									 gano?: bool,
									 perdio?: bool ⟩

Solución Informal:
	- e.arg₀ + 1 debe ser ...
	- si e.arg₁ ...
---
Invariante de Representación:
	Rep:	estr	->	boolean
	(∀e: estr) Rep(e)	≡ true ⇐⇒ (1)∧(2)
		donde: 
		(1)	≡	e.arg₀ > ...
		(2)	≡	(∀n: nat)(e.arg₁ < ...)
---
Función de abstracción:
	Abs:	estr	->	tipoDato	{Rep(e)}
	(∀e: estr) Abs(e) =obs td: tipoDato | (1)∧(2)
		donde: 
		(1)	≡	obs₁(td) = ...
		(2)	≡	obs₂(td) = ...
---
Interfaz:
Se explica con:	Partida
	Géneros:		partida
	
	Operaciones básicas:
		NuevaPartida(in m: mapa, in t: array(array(tupla(bool, bool, bool))))	-> res: partida
		Pre ≡ {true}
		Post ≡ {res =obs nuevaPartida(m)}
		Complejidad: O(c) ?
		Descripción: Genera una nueva partida.
		Aliasing: tablero se pasa por referencia.
		---	
		Mover(inout p: partida, in d: direccion)
		Pre ≡ {p =obs p₀ ∧ no gano y no perdio?}
		Post ≡ {p =obs mover(p₀, d)}
		Complejidad: Θ(1)
		Descripción: Mover al jugador.
		---
		Mapa(in p: partida) -> res: mapa
		Pre ≡ {true}
		Post ≡ {res =obs mapa(p)}
		Complejidad: Θ(1)
		Descripción: Devuelve el mapa xD
		Aliasing: Devuelve una referencia inmutable.
		---
		Jugador(in p: partida) -> res: coordenadas
		Pre ≡ {true}
		Post ≡ {res =obs jugador(p)}
		Complejidad: Θ(1)
		Descripción: Devuelve las coordenadas del jugador.
		Aliasing: Devuelve una referencia inmutable.
		---
		CantMov(in p: partida) -> res: nat
		Pre ≡ {true}
		Post ≡ {res =obs cantMov(p)}
		Complejidad: Θ(1)
		Descripción: ...
		Aliasing: Devuelve una referencia inmutable.
		---
		Inmunidad(in p: partida) -> res: nat 
		Pre ≡ {true}
		Post ≡ {res =obs inmunidad(p)}
		Complejidad: Θ(1)
		Descripción: ...
		Aliasing: Devuelve una referencia inmutable.
		---
		Gano(in p: partida) -> res: bool
		Pre ≡ {true}
		Post ≡ {res =obs ganó?(p)}
		Complejidad: Θ(1)
		Descripción: ...
		---
		Perdio(in p: partida) -> res: bool
		Pre ≡ {true}
		Post ≡ {res =obs perdió?(p)}
		Complejidad: Θ(1)
		Descripción: ...
		---
	Algoritmos del módulo:
		NuevaPartida(in m: mapa, in t: array(array(typla⟨bool, bool, bool⟩))) -> res: Partida 
		{
				res = ⟨ mapa = m,
				 tablero = t,
				 coordenadaActual = m.inicio,
				 cantMov = 0,
				 movsInmunes = 0,
				 gano? = false,
				 perdio? = false ⟩
				 
				 return res;
		}
		---
		Mover(inout p: partida, in dir: direccion)
		{
			if( !(p.gano? || p.perdio?) && p.esMovimientoValido(p.mapa, p.tablero, p.coordenadaActual, dir) ){
				if( dir == "DER" ){
					
					p.coordenadaActual = ⟨ π₀(p.coordenadaActual)+1, π₁(p.coordenadaActual) ⟩; // π₁(p.coordenadaActual) = π₁(p.coordenadaActual) + 1;
					
				}else if( dir == "IZQ" ){
					
					p.coordenadaActual = ⟨ π₀(p.coordenadaActual)-1, π₁(p.coordenadaActual) ⟩;
					
				}else if( dir == "ARR" ){
					
					p.coordenadaActual = ⟨ π₀(p.coordenadaActual), π₁(p.coordenadaActual)+1 ⟩;
					
				}else if( dir == "ABJ" ){
					
					p.coordenadaActual = ⟨ π₀(p.coordenadaActual), π₁(p.coordenadaActual)-1 ⟩;
					
				}
				
				cantMov++;
				if(p.movsInmunes > 0) p.movsInmunes--;
				if( p.mapa.esChocolate(p.tablero, p.coordenadaActual) ){
					p.movsInmunes = p.movsInmunes + 10; 
					π₂(p.tablero[π₀(coordenadaActual)][π₁(coordenadaActual)]) = false; 
				} 	
				if(p.mapa.seAsusta(p.mapa, p.tablero, p.coordenadaActual)){
					 p.perdio? = true;
				}else if( p.mapa.llegada = p.coordenadaActual ){ 
					p.gano? = true;
				}
			}
		}
		---
		Mapa(in p: partida) -> res: mapa
		{
			return p.mapa;
		}
		---
		Jugador(in p: partida) -> res: coordenada
		{
			return p.coordenadaActual;
		}
		---
		CantMov(in p: partida) -> res: nat{
			return p.cantMov;
		}
		---
		Inmunidad(in p: partida) -> res: nat{
			return p.movsInmunes;
		}
		---
		Gano(in p: partida) -> res: bool
		{
			return p.gano?;
		}
		---
		Perdio(in p: partida) -> res: bool
		{
			return p.perdio?;
		}
		---
		// Auxiliares
		esChocolate(in t: array(array(tupla⟨bool, bool, bool⟩)), in c: coordenada){
				return π₂(t[π₀(c)][π₁(c)]);
		}
		---
		esFantasma(in t: array(array(tupla⟨bool, bool, bool⟩)), in c: coordenada){
			return π₁(t[π₀(c)][π₁(c)]);
		}
		---
		esPared(in t: array(array(tupla⟨bool, bool, bool⟩)), in c: coordenada){
			return π₀(t[π₀(c)][π₁(c)]);
		}
		---
		esMovimientoValido(in m: mapa, in t: array(array(tupla⟨bool, bool, bool⟩)), in c: coordenada, in dir: direccion/string) -> res: bool
		{
			if( dir == "DER" ){
				
				return esPosicionLibre(m, t, ⟨π₀(c)+1, π₁(c)⟩);
				
			}else if( dir == "IZQ" ){
				
				return esPosicionLibre(m, t, ⟨π₀(c)-1, π₁(c)⟩);
				
			}else if( dir == "ARR" ){
				
				return esPosicionLibre(m, t, ⟨π₀(c), π₁(c)+1⟩);
				
			}else if( dir == "ABJ" ){
				
				return esPosicionLibre(m, t, ⟨π₀(c), π₁(c)-1⟩);
				
			}else{
				return false;
			}
		}
		---
		esPosicionLibre(in m: mapa, in t: array(array(tupla⟨bool, bool, bool⟩)), in c: coordenada) -> res: bool
		{
				if( 0 <= π₀(c) && π₀(c) < m.largo && 0 <= π₁(c) && π₁(c) < m.alto ){
					return !esPared(t, c) // checkeo que la 3ra posicion de la coordenada pasada sea false, osea no una pared
				}else{
					return false;
				}
		}
		---
		seAsusta?(in m: mapa, in t: array(array(tupla⟨bool, bool, bool⟩)), in c: coordenada) -> res: bool
		{
				posACheckear = {
					⟨ π₀(c)-3, π₁(c) ⟩, ⟨ π₀(c)-2, π₁(c)-1 ⟩, ⟨ π₀(c)-2, π₁(c)+1 ⟩, ⟨ π₀(c)-1, π₁(c)-2 ⟩, ⟨ π₀(c)-1, π₁(c)+2 ⟩, ⟨ π₀(c), π₁(c)-3 ⟩,
					⟨ π₀(c), π₁(c)+3 ⟩, ⟨ π₀(c)+1, π₁(c)-2 ⟩, ⟨ π₀(c)+1, π₁(c)+2 ⟩, ⟨ π₀(c)+2, π₁(c)-1 ⟩, ⟨ π₀(c)+2, π₁(c)+1 ⟩, ⟨ π₀(c)+3, π₁(c) ⟩
				};
				i = 0;
				while(i < 12){
					if( π₀(posACheckear[i]) > 0 && π₀(posACheckear[i]) < m.largo && π₁(posACheckear[i]) > 0 && π₁(posACheckear[i]) < m.alto ){
						if( esFantasma(t, posACheckear) ) return true;
					}
					++i;
				}
				
				return false;
		}
		
		- - - x - - -
		- - x - x - -
		- x - - - x -	
		x - - o - - x			⇐ Lugares a revisar que no haya fantasmas, solo habria que checkear estos porque no puede ocurrir que este a menos distancia de algun fantasma sin haber perdido antes.
		- x - - - x -	
		- - x - x - -
		- - - x - - -
