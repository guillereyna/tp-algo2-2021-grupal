Representación:
	fichín se representa con estr donde 
		estr es tupla ⟨	m: puntero(mapa),
						tablero: array(array(tupla(bool, bool, bool)))
						p: puntero(partida),
						hayAlguien: bool,
						jugador: string,
						ranking: diccTrie(string, nat)⟩

Solución Informal:
	- m: debe ser igual al mapa de p (partida)
	- tablero: debe ser igual al mapa
	- hayAlguien: es true si y solo si jugador es distinto de "" 
---	
Invariante de Representación:
	Rep:	estr	->	boolean
	(∀e: estr) Rep(e)	≡ true ⇐⇒ (1)∧(2)∧(3)
		donde: 
		(1)	≡	e.m = (mapa(e.p)) 
		(2)	≡	e.hayAlguien = true ⇐⇒ e.jugador ≠ ""
		(3) ≡ (∀ i,j:nat)((0 ≤ i < e.m.largo ∧ 0 ≤ j < e.m.alto) ⇒ (π₀(e.tablero[i][j]) ↔ tupla(i,j) ∈ e.m.paredes)) ∧L
					(∀ i,j:nat)((0 ≤ i < e.m.largo ∧ 0 ≤ j < e.m.alto) ⇒ (π₁(e.tablero[i][j]) ↔ tupla(i,j) ∈ e.m.fantasmas)) ∧L
					(∀ i,j:nat)((0 ≤ i < e.m.largo ∧ 0 ≤ j < e.m.alto) ⇒ (π₂(e.tablero[i][j]) ↔ tupla(i,j) ∈ e.m.chocolates))
---
Función de abstracción:
	Abs:	estr	->	fichín	{Rep(e)}
	(∀e: estr) Abs(e) =obs f: fichín | (1)∧(2)
		donde: 
		(1)	≡	obs₁(td) = ...
		(2)	≡	obs₂(td) = ...
		
		e.m = mapa(fichin)
		e.p = partida(fichin)
		e.hayAlguien = alguienJugando?(fichin)
		e.jugador = jugadorActual(fichin)
		e.ranking = ranking(fichin)
		
		
---
Interfaz:
	Se explica con:	Fichín
	Géneros:		fichín
	
	Operaciones básicas:
		NuevoFichín(in m: mapa)	-> res: fichín
		Pre ≡ {true}
		Post ≡ {res =obs nuevoFichín(m)}
		Complejidad: Θ(1)?
		Descripción: Genera un nuevo fichín.
		Aliasing: ?
		---		
		
		NuevaPartida(inout f: fichín, in j: jugador)
		Pre ≡ {f = f₀ ∧ ¬alguienJugando?(f₀)}
		Post ≡ {f =obs nuevaPartida(f₀, j)}
		Complejidad: Θ(c)
		Descripción: Crea una partida para el jugador especificado, en este proceso tambien se restauran los chocolates en el mapa.
		---
		
		Mover(inout f: fichín, in d: dirección)
		Pre ≡ {f = f₀ ∧ alguienJugando?(f)}
		Post ≡ {f =obs mover(f₀, d)}
		Complejidad: Θ(1) normalmente / Θ(|J|) cuando ganó o perdió
		Descripción: ...
		Aliasing: ?
		---
		
		Mapa(in f: fichín) -> res: mapa
		Pre ≡ {true}
		Post ≡ {res =obs mapa(f)}
		Complejidad: Θ(1)
		Descripción: Devuelve el mapa actual
		Aliasing: Se devuelve una referencia inmutable.
		---
		
		AlguienJugando?(in f: fichín) -> res: bool
		Pre ≡ {true}
		Post ≡ {res =obs alguienJugando?(f)}
		Complejidad: Θ(1)
		Descripción: ...
		---
		
		JugadorActual(in f: fichín) -> res: jugador
		Pre ≡ {alguienJugando?(f)}
		Post ≡ {res =obs jugadorActual(f₀)}
		Complejidad: Θ(1)
		Descripción: Devuelve el nombre del jugador actual
		Aliasing: Se devuelve una referencia inmutable.
		---
		
		PartidaActual(in f: fichín) -> res: partida
		Pre ≡ {alguienJugando?(f)}
		Post ≡ {res = obs PartidaActual(f)}
		Complejidad: Θ(1)
		Descripción: ...
		Aliasing: Se devuelve una referencia inmutable.
		---
		
		Ranking(in fichín: f) -> res: ranking
		Pre ≡ {true}
		Post ≡ {res =obs ranking(f)}
		Complejidad: Θ(1)
		Descripción: Devuelve el diccionario usado en el fichin.
		Aliasing: Se devuelve una referencia inmutable.
		---
		
		Objetivo(in f: fichín, out t: tupla(jugador, nat)) -> res: bool
		Pre ≡ {alguienJugando?(f)}
		Post ≡ {si res es true, devuelve el objetivo, sino, no importa.
		las condiciones son: está en el ranking y no es el primero.}
		Complejidad:
		Descripción:
		Aliasing:
		---
		
		
	Algoritmos del módulo:
	
		iNuevoFichín(in m: puntero(mapa)) -> res: estr
			res.mapa <- m
			res.tablero <- inicializarTablero(m)
			res.partida <- null
			res.enCurso <- false
			res.ranking <- Vacío()
			res.jugador <- ""
		---
			
		iNuevaPartida(in/out f: estr, in j: string)
			RepoblarChocolates(f.tablero, f.m)
			f.p <- NuevaPartida(f.m, &f.tablero)      O(1)
 			f.hayAlguien <- true          O(1)
			f.jugador <- j                O(1)
		Complejidad: Θ(c)
		Justificación: Cuando se repueblan los chocolates se hace en O(c) dado a que se recorre un arreglo con las coordenadas de estas para restaurar los chocolates.
		Esto sumado a las operaciones en O(1) que le siguen dan como resultado a una complejidad O(c)
		---
		
		iMover(inout f: estr, in d: dirección)
			Mover(f->partida, d)
			if (Ganó?(f->partida) ∧ (Def?(f.jugador, f.ranking) ∧ CantMov(f->partida) < f.ranking[f.jugador]) ∨ (¬ Def?(f.jugador, f.ranking)) then
					Definir(f.ranking, f.jugador, CantMov(f->partida))
					f.enCurso <- false
		---
		
		iMapa(in f: estr) -> res: puntero(mapa)
			res <- f.m //devuelve una refrencia
		Complejidad: Θ(1)
		
		---
		iAlguienJugando?(in f: estr) -> res: bool
			res <- f.enCurso
			
		---
		iJugadorActual(in f: estr) -> res: string
			res <- f.jugador
		Complejidad: Θ(1)
		
		---
		iPartidaActual(in f: estr) -> res: partida
			res <- f->partida
			
		---
		iRanking(in f: estr) -> res: ranking
			res <- f.ranking
		Complejidad: Θ(1)
	
	  ---
		iObjetivo(in f: fichín) -> res: tupla(jugador, nat)
			Busca en el ranking al jugador con el próximo puntaje más alto y devuelve
			en una tupla su nombre y su puntaje.
			Habría que hacer tener otro ranking pero en forma de secuencia para no tener
			que estar recorriendo el trie? Cuánto cuesta recorrerlo??
			En ese caso sería:
			rankingLineal = ConjuntoLineal(itDiccTrie(jugador, nat))
		
		---
		iInicializarTablero(in m: mapa)
		t = arreglo[largo(m)] de arreglo[alto(m)] de tupla ⟨bool, bool, bool⟩(false)
		for c in chocolates(m) do
			π₂(t[π₀(c)][π₁(c)]) = true
		end for
		for p in paredes(m) do
			π₀(t[π₀(p)][π₁(p)]) = true
		end for
		for f in fantasmas(m) do
			π₁(t[π₀(f)][π₁(f)]) = true
		end for
		
		---
		iRepoblarChocolates(in/out t: tablero, in m: mapa)
			for c in Chocolates(m) do
				π₂(t[π₀(c)][π₁(c)]) = true
			end for
		Complejidad: Θ(c)
		
TRIE

---
Interfaz:
	Parámetros formales:
	Se explica con:	Diccionario
	Géneros:		diccTrie
	
	Operaciones básicas:
		Vacío()	-> res: tipoDato
		Pre ≡ {true}
		Post ≡ {res =obs ...}
		Complejidad: Θ(1)
		Descripción: Genera ...
		Aliasing: No presenta aspectos de aliasing.
		---
